from .__common__ import *
from .document import Document
from .view import View, ViewResults
from .find import Find
from .exceptions import *
from typing import Callable, Mapping, Iterable

class Database(object):
    """Representation of a database on a CouchDB server.

    >>> server = Server()
    >>> db = server.create('python-tests')

    New documents can be added to the database using the `save()` method:

    >>> doc_id, doc_rev = db.save({'type': 'Person', 'name': 'John Doe'})

    This class provides a dictionary-like interface to databases: documents are
    retrieved by their ID using item access

    >>> doc = db[doc_id]
    >>> doc                 #doctest: +ELLIPSIS
    <Document u'...'@... {...}>

    Documents are represented as instances of the `Row` class, which is
    basically just a normal dictionary with the additional attributes ``id`` and
    ``rev``:

    >>> doc.id, doc.rev     #doctest: +ELLIPSIS
    (u'...', ...)
    >>> doc['type']
    u'Person'
    >>> doc['name']
    u'John Doe'

    To update an existing document, you use item access, too:

    >>> doc['name'] = 'Mary Jane'
    >>> db[doc.id] = doc

    The `save()` method creates a document with a random ID generated by
    CouchDB (which is not recommended). If you want to explicitly specify the
    ID, you'd use item access just as with updating:

    >>> db['JohnDoe'] = {'type': 'person', 'name': 'John Doe'}

    >>> 'JohnDoe' in db
    True
    >>> len(db)
    2

    >>> del server['python-tests']
    """

    def __init__(self, url: str, name: str, session: requests.Session):
        if not url.startswith('http'): #TODO I think we could use a smarter urljoin
            url = DEFAULT_BASE_URL + url
        self.url = url
        self.session = session
        self._name = name

    def __repr__(self) -> str:
        return '<%s %r>' % (type(self).__name__, self.name)

    def __contains__(self, id: str) -> bool:
        """Return whether the database contains a document with the specified
        ID.

        :param id: the document ID
        :return: `True` if a document with the ID exists, `False` otherwise
        """
        response = self.session.head(urljoin(self.url, id))
        return response.ok

    def __iter__(self):
        """Return the IDs of all documents in the database."""
        return iter([item.id for item in self.view('_all_docs')])

    def __len__(self):
        """Return the number of documents in the database."""
        response = self.session.get(self.url)
        if not response.ok: raise CouchDBException.auto(response.json())
        data = response.json()
        return data['doc_count']

    def __nonzero__(self):
        """Return whether the database is available."""
        return self.session.head(self.url).ok

    def __bool__(self):
        return self.session.head(self.url).ok

    def __delitem__(self, id: str):
        """Remove the document with the specified ID from the database.

        Fetches the latest rev from the database to do the deletion.

        WARNING! This bypasses CouchDB's rev-based data integrity constraints,
        meaning it will delete the document even if someone else has edited
        the document since you last fetched it from the DB

        :param id: the document ID
        """
        docUrl = urljoin(self.url, id)
        response1 = self.session.head(docUrl)
        rev = response1.headers['ETag'].strip('"')
        response2 = self.session.delete(docUrl, params={'rev': rev})
        if not response2.ok: raise CouchDBException.auto(response2.json)

    def __getitem__(self, id: str) -> Document:
        """Return the document with the specified ID.

        :param id: the document ID
        :return: a `Row` object representing the requested document
        """
        response = self.session.get(urljoin(self.url, id))
        if not response.ok: raise CouchDBException.auto(response.json())
        return Document(response.json())

    def __setitem__(self, id: str, data: Mapping):
        """Create or update a document with the specified ID.

        :param id: the document ID
        :param content: the document content; either a plain dictionary for
                        new documents, or a `Row` object for existing
                        documents
        """
        response = self.session.put(urljoin(self.url, id), json=data)
        if not response.ok: raise CouchDBException.auto(response.json())
        data.update({'_id': data['id'], '_rev': data['rev']})
    

    def all_docs(self, wrapper: Callable = None, **options) -> ViewResults:
        return self.view('_all_docs', wrapper, **options)
        

    @property
    def name(self) -> str:
        """The name of the database.

        Note that this may require a request to the server unless the name has
        already been cached by the `info()` method.
        """
        if self._name is None:
            self.info()
        return self._name

    @property
    def security(self):
        response = self.session.get(urljoin(self.url, '_security'))
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()

    @security.setter
    def security(self, doc):
        response = self.session.put('_security', json=doc)
        if not response.ok: raise CouchDBException.auto(response.json())



    def save(self, doc: Mapping, **params) -> (str, str):
        """Create a new document or update an existing document.

        If doc has no _id then the server will allocate a random ID and a new
        document will be created. Otherwise the doc's _id will be used to
        identify the document to create or update. Trying to update an existing
        document with an incorrect _rev will raise a ResourceConflict exception.

        Note that it is generally better to avoid saving documents with no _id
        and instead generate document IDs on the client side. This is due to
        the fact that the underlying HTTP ``POST`` method is not idempotent,
        and an automatic retry due to a problem somewhere on the networking
        stack may cause multiple documents being created in the database.

        To avoid such problems you can generate a UUID on the client side.
        Python (since version 2.5) comes with a ``uuid`` module that can be
        used for this::

            from uuid import uuid4
            doc = {'_id': uuid4().hex, 'type': 'person', 'name': 'John Doe'}
            db.save(doc)

        :param doc: the document to store
        :param options: optional args, e.g. batch='ok'
        :return: (id, rev) tuple of the saved document
        """
        if '_id' in doc:
            url = urljoin(self.url, doc['_id'])
        else:
            url = self.url
        
        response = self.session.put(url, json=doc, params=params)

        if not response.ok: raise CouchDBException.auto(response.json())

        data = response.json()
        id, rev = data['id'], data.get('rev')
        doc['_id'] = id
        if rev is not None: # Not present for batch='ok'
            doc['_rev'] = rev
        return id, rev

    def cleanup(self) -> bool:
        """Clean up old design document indexes.

        Remove all unused index files from the database storage area.
        """
        response = self.session.post(urljoin(self.url, '_view_cleanup'))
        if not response.ok: raise CouchDBException.auto(response.json())

    def commit(self):
        """If the server is configured to delay commits, or previous requests
        used the special ``X-Couch-Full-Commit: false`` header to disable
        immediate commits, this method can be used to ensure that any
        non-committed changes are committed to physical storage.
        """
        response = self.session.post(urljoin(self.url, '_ensure_full_commit'))
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()

    def compact(self, ddoc=None):
        """Compact the database or a design document's index.

        Without an argument, this will try to prune all old revisions from the
        database. With an argument, it will compact the index cache for all
        views in the design document specified.
        """
        url = urljoin(self.url, '_compact')
        if ddoc:
            url = urljoin(url, ddoc)
        
        response = self.session.post(url)
        if not response.ok: raise CouchDBException.auto(response.json())

    def copy(self, src, dest):
        """Copy the given document to create a new document.

        :param src: the ID of the document to copy, or a dictionary or
                    `Document` object representing the source document.
        :param dest: either the destination document ID as string, or a
                     dictionary or `Document` instance of the document that
                     should be overwritten.
        :return: the new revision of the destination document
        :rtype: `str`
        :since: 0.6
        """
        if not isinstance(src, util.strbase):
            if not isinstance(src, dict):
                if hasattr(src, 'items'):
                    src = dict(src.items())
                else:
                    raise TypeError('expected dict or string, got %s' %
                                    type(src))
            src = src['_id']

        if not isinstance(dest, util.strbase):
            if not isinstance(dest, dict):
                if hasattr(dest, 'items'):
                    dest = dict(dest.items())
                else:
                    raise TypeError('expected dict or string, got %s' %
                                    type(dest))
            if '_rev' in dest:
                dest = '%s?%s' % (urlquote(dest['_id']),
                                  urlencode({'rev': dest['_rev']}))
            else:
                dest = urlquote(dest['_id'])

        response = self.session.request('COPY', src, headers={'Destination': dest})
        if not response.ok: raise CouchDBException.auto(response.json())
        data = response.json()
        return data['rev']

    def delete(self, doc):
        """Delete the given document from the database.

        Use this method in preference over ``__del__`` to ensure you're
        deleting the revision that you had previously retrieved. In the case
        the document has been updated since it was retrieved, this method will
        raise a `ResourceConflict` exception.

        >>> server = Server()
        >>> db = server.create('python-tests')

        >>> doc = dict(type='Person', name='John Doe')
        >>> db['johndoe'] = doc
        >>> doc2 = db['johndoe']
        >>> doc2['age'] = 42
        >>> db['johndoe'] = doc2
        >>> db.delete(doc) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
          ...
        ResourceConflict: (u'conflict', u'Document update conflict.')

        >>> del server['python-tests']

        :param doc: a dictionary or `Document` object holding the document data
        """
        if doc['_id'] is None:
            raise ValueError('document ID cannot be None')
        response = self.session.delete(urljoin(self.url, doc['_id']), params={'rev': doc['_rev']})
        if not response.ok: raise CouchDBException.auto(response.json())

    def get(self, id, default=None, **options):
        """Return the document with the specified ID. Unlike using the
        [] syntax, this does not throw an exception on 404 errors,
        instead using the given default.

        :param id: the document ID
        :param default: the default value to return when the document is not found.
        :return: a `Document` object representing the requested document, or `None`
                 if no document with the ID was found
        :rtype: `Document`
        """
        response = self.session.get(urljoin(self.url, id))
        if response.status_code == 404: return default
        if not response.ok: raise CouchDBException.auto(response.json())
        return Document(response.json())

    def revisions(self, id, **options):
        """Generator to yield all available revisions of the given document.

        :param id: the document ID
        :return: an iterator over Document objects, each a different revision,
                 in reverse chronological order, if any were found
        """
        data = self.get(id, revs=True)

        #TODO I don't know that the following code is correct with current version of CouchDB
        startrev = data['_revisions']['start']
        for index, rev in enumerate(data['_revisions']['ids']):
            options['rev'] = '%d-%s' % (startrev - index, rev)
            revision = self.get(id, **options)
            if revision is None:
                return
            yield revision

    def info(self, ddoc=None):
        """Return information about the database or design document as a
        dictionary.

        Without an argument, returns database information. With an argument,
        return information for the given design document.

        The returned dictionary exactly corresponds to the JSON response to
        a ``GET`` request on the database or design document's info URI.

        :return: a dictionary of database properties
        :rtype: ``dict``
        :since: 0.4
        """
        url = self.url
        if ddoc is not None:
            url = urljoin(url, '_design', ddoc, '_info')

        response = self.session.get(url)
        if not response.ok: raise CouchDBException.auto(response.json())
        data = response.json()

        if ddoc is None:
            self._name = data['db_name']
        return data

    def delete_attachment(self, doc, filename):
        """Delete the specified attachment.

        Note that the provided `doc` is required to have a ``_rev`` field.
        Thus, if the `doc` is based on a view row, the view row would need to
        include the ``_rev`` field.

        :param doc: the dictionary or `Document` object representing the
                    document that the attachment belongs to
        :param filename: the name of the attachment file
        :since: 0.4.1
        """
        url = urljoin(self.url, doc['_id'], filename)
        response = self.session.get(url, params={'rev': doc['_rev']})
        if not response.ok: raise CouchDBException.auto(response.json())
        data = response.json()
        doc['_rev'] = data['rev']

    def get_attachment(self, id_or_doc, filename, default=None):
        """Return an attachment from the specified doc id and filename.

        :param id_or_doc: either a document ID or a dictionary or `Document`
                          object representing the document that the attachment
                          belongs to
        :param filename: the name of the attachment file
        :param default: default value to return when the document or attachment
                        is not found
        :return: a file-like object with read and close methods, or the value
                 of the `default` argument if the attachment is not found
        :since: 0.4.1
        """
        if isinstance(id_or_doc, util.strbase):
            id = id_or_doc
        else:
            id = id_or_doc['_id']
        
        url = urljoin(self.url, id, filename)
        response = self.session.get(url)
        if response.status_code == 404 and default is not None: return default
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()

    def put_attachment(self, doc, content, filename=None, content_type=None):
        """Create or replace an attachment.

        Note that the provided `doc` is required to have a ``_rev`` field. Thus,
        if the `doc` is based on a view row, the view row would need to include
        the ``_rev`` field.

        :param doc: the dictionary or `Document` object representing the
                    document that the attachment should be added to
        :param content: the content to upload, either a file-like object or
                        a string
        :param filename: the name of the attachment file; if omitted, this
                         function tries to get the filename from the file-like
                         object passed as the `content` argument value
        :param content_type: content type of the attachment; if omitted, the
                             MIME type is guessed based on the file name
                             extension
        :since: 0.4.1
        """
        if filename is None:
            if hasattr(content, 'name'):
                filename = os.path.basename(content.name)
            else:
                raise ValueError('no filename specified for attachment')
        if content_type is None:
            content_type = ';'.join(
                filter(None, mimetypes.guess_type(filename))
            )

        url = urljoin(self.url, doc['_id'], filename)
        response = self.session.put(
            url, 
            content, 
            headers={
                'Content-Type': content_type
            },
            params={
                'rev': doc['_rev']
            }
        )
        
        if not response.ok: raise CouchDBException.auto(response.json())
        data = response.json()
        doc['_rev'] = data['rev']

    def find(self, mango_query, wrapper=None, auto_paginate=False):
        """Execute a mango find-query against the database.

        Note: only available for CouchDB version >= 2.0.0

        More information on the `mango_query` structure can be found here:
          http://docs.couchdb.org/en/master/api/database/find.html#find-selectors

        >>> server = Server()
        >>> db = server.create('python-tests')
        >>> db['johndoe'] = dict(type='Person', name='John Doe')
        >>> db['maryjane'] = dict(type='Person', name='Mary Jane')
        >>> db['gotham'] = dict(type='City', name='Gotham City')
        >>> mango = {'selector': {'type': 'Person'},
        ...          'fields': ['name'],
        ...          'sort':[{'name': 'asc'}]}
        >>> for row in db.find(mango):                          # doctest: +SKIP
        ...    print(row['name'])                               # doctest: +SKIP
        John Doe
        Mary Jane
        >>> del server['python-tests']

        :param mango_query: a dictionary describing criteria used to select
                            documents
        :param wrapper: an optional callable that should be used to wrap the
                        resulting documents
        :param auto_paginate: If True, abstract the process of paging through the results.
                              This will result in multiple calls to the database server if
                              there are more results than the limit specified in the query.
                              (CouchDB's default limit is 25 if you do not specify a limit.)
        :return: the query results as a `Find` iterable object
        """
        find = Find(
            url = urljoin(self.url, '_find'), 
            query = mango_query, 
            wrapper = wrapper, 
            session = self.session, 
            auto_paginate = auto_paginate, 
        )
        if auto_paginate: 
            return find # Allow the iterable to auto-paginate
        else:
            return find.execute() # Return a single result set
        

    def explain(self, mango_query):
        """Explain a mango find-query.

        Note: only available for CouchDB version >= 2.0.0

        More information on the `mango_query` structure can be found here:
          http://docs.couchdb.org/en/master/api/database/find.html#db-explain

        >>> server = Server()
        >>> db = server.create('python-tests')
        >>> db['johndoe'] = dict(type='Person', name='John Doe')
        >>> db['maryjane'] = dict(type='Person', name='Mary Jane')
        >>> db['gotham'] = dict(type='City', name='Gotham City')
        >>> mango = {'selector': {'type': 'Person'}, 'fields': ['name']}
        >>> db.explain(mango)                          #doctest: +ELLIPSIS +SKIP
        {...}
        >>> del server['python-tests']

        :param mango_query: a `dict` describing criteria used to select
                            documents
        :return: the query results as a list of `Document` (or whatever
                 `wrapper` returns)
        :rtype: `dict`
        """
        response = self.session.post(urljoin(self.url, '_explain'), mango_query)
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()



    def bulk_update(self, documents, **options):
        """Perform a bulk update or insertion of the given documents using a
        single HTTP request.

        >>> server = Server()
        >>> db = server.create('python-tests')
        >>> for doc in db.update([
        ...     Document(type='Person', name='John Doe'),
        ...     Document(type='Person', name='Mary Jane'),
        ...     Document(type='City', name='Gotham City')
        ... ]):
        ...     print(repr(doc)) #doctest: +ELLIPSIS
        (True, u'...', u'...')
        (True, u'...', u'...')
        (True, u'...', u'...')

        >>> del server['python-tests']

        The return value of this method is a list containing a tuple for every
        element in the `documents` sequence. Each tuple is of the form
        ``(success, docid, rev_or_exc)``, where ``success`` is a boolean
        indicating whether the update succeeded, ``docid`` is the ID of the
        document, and ``rev_or_exc`` is either the new document revision, or
        an exception instance (e.g. `ResourceConflict`) if the update failed.

        If an object in the documents list is not a dictionary, this method
        looks for an ``items()`` method that can be used to convert the object
        to a dictionary. Effectively this means you can also use this method
        with `mapping.Document` objects.

        :param documents: a sequence of dictionaries or `Document` objects, or
                          objects providing a ``items()`` method that can be
                          used to convert them to a dictionary
        :return: The decoded JSON response from CouchDB
        :rtype: ``list``

        :since: version 0.2
        """
        docs = []
        for doc in documents:
            if isinstance(doc, dict):
                docs.append(doc)
            elif hasattr(doc, 'items'):
                docs.append(dict(doc.items()))
            else:
                raise TypeError('expected dict, got %s' % type(doc))

        content = options
        content.update(docs=docs)
        response = self.session.post('_bulk_docs', content)
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()

    def purge(self, docs):
        """Perform purging (complete removing) of the given documents.

        Uses a single HTTP request to purge all given documents. Purged
        documents do not leave any meta-data in the storage and are not
        replicated.
        """
        content = {}
        for doc in docs:
            if isinstance(doc, dict):
                content[doc['_id']] = [doc['_rev']]
            elif hasattr(doc, 'items'):
                doc = dict(doc.items())
                content[doc['_id']] = [doc['_rev']]
            else:
                raise TypeError('expected dict, got %s' % type(doc))
        response = self.session.post(urljoin(self.url, '_purge'), content)
        if not response.ok: raise CouchDBException.auto(response.json())
        return response.json()

    def view(self, name: str, wrapper: Callable = None, **options) -> ViewResults:
        """Execute a predefined view.

        >>> server = Server()
        >>> db = server.create('python-tests')
        >>> db['gotham'] = dict(type='City', name='Gotham City')

        >>> for row in db.view('_all_docs'):
        ...     print(row.id)
        gotham

        >>> del server['python-tests']

        :param name: the name of the view; for custom views, use the format
                     ``design_docid/viewname``, that is, the document ID of the
                     design document and the name of the view, separated by a
                     slash
        :param wrapper: an optional callable that should be used to wrap the
                        result rows
        :param options: optional query string parameters
        :return: the view results
        """
        return View(urljoin(self.url, name), wrapper, self.session)(**options)
        

    def iterview(self, name, batch, wrapper=None, **options):
        """Iterate the rows in a view, fetching rows in batches and yielding
        one row at a time.

        Since the view's rows are fetched in batches any rows emitted for
        documents added, changed or deleted between requests may be missed or
        repeated.

        :param name: the name of the view; for custom views, use the format
                     ``design_docid/viewname``, that is, the document ID of the
                     design document and the name of the view, separated by a
                     slash.
        :param batch: number of rows to fetch per HTTP request.
        :param wrapper: an optional callable that should be used to wrap the
                        result rows
        :param options: optional query string parameters
        :return: row generator
        """
        # Check sane batch size.
        if batch <= 0:
            raise ValueError('batch must be 1 or more')
        # Save caller's limit, it must be handled manually.
        limit = options.get('limit')
        if limit is not None and limit <= 0:
            raise ValueError('limit must be 1 or more')
        while True:

            loop_limit = min(limit or batch, batch)
            # Get rows in batches, with one extra for start of next batch.
            options['limit'] = loop_limit + 1
            rows = list(self.view(name, wrapper, **options))

            # Yield rows from this batch.
            for row in itertools.islice(rows, loop_limit):
                yield row

            # Decrement limit counter.
            if limit is not None:
                limit -= min(len(rows), batch)

            # Check if there is nothing else to yield.
            if len(rows) <= batch or (limit is not None and limit == 0):
                break

            # Update options with start keys for next loop.
            options.update(startkey=rows[-1]['key'],
                           startkey_docid=rows[-1]['id'], skip=0)

    def show(self, name, docid=None, **options):
        """Call a 'show' function.

        :param name: the name of the show function in the format
                     ``designdoc/showname``
        :param docid: optional ID of a document to pass to the show function.
        :param options: optional query string parameters
        :return: (headers, body) tuple, where headers is a dict of headers
                 returned from the show function and body is a readable
                 file-like instance
        """
        path = _path_from_name(name, '_show')
        if docid:
            path.append(docid)
        status, headers, body = self.resource(*path).get(**options)
        return headers, body

    def list(self, name, view, **options):
        """Format a view using a 'list' function.

        :param name: the name of the list function in the format
                     ``designdoc/listname``
        :param view: the name of the view in the format ``designdoc/viewname``
        :param options: optional query string parameters
        :return: (headers, body) tuple, where headers is a dict of headers
                 returned from the list function and body is a readable
                 file-like instance
        """
        path = _path_from_name(name, '_list')
        path.extend(view.split('/', 1))
        _, headers, body = _call_viewlike(self.resource(*path), options)
        return headers, body

    def update_doc(self, name, docid=None, **options):
        """Calls server side update handler.

        :param name: the name of the update handler function in the format
                     ``designdoc/updatename``.
        :param docid: optional ID of a document to pass to the update handler.
        :param options: additional (optional) params to pass to the underlying
                        http resource handler, including ``headers``, ``body``,
                        and ```path```. Other arguments will be treated as
                        query string params. See :class:`couchdb.http.Resource`
        :return: (headers, body) tuple, where headers is a dict of headers
                 returned from the list function and body is a readable
                 file-like instance
        """
        path = _path_from_name(name, '_update')
        if docid is None:
            func = self.resource(*path).post
        else:
            path.append(docid)
            func = self.resource(*path).put
        _, headers, body = func(**options)
        return headers, body

    def _changes(self, **opts):
        # use streaming `get` and `post` methods
        if opts.get('filter') == '_selector':
            selector = opts.pop('_selector', None)
            _, _, data = self.resource.post('_changes', selector, **opts)
        else:
            _, _, data = self.resource.get('_changes', **opts)
        lines = data.iterchunks()
        for ln in lines:
            if not ln: # skip heartbeats
                continue
            doc = json.decode(ln.decode('utf-8'))
            if 'last_seq' in doc: # consume the rest of the response if this
                for ln in lines:  # was the last line, allows conn reuse
                    pass
            yield doc

    def changes(self, **opts):
        """Retrieve a changes feed from the database.

        :param opts: optional query string parameters
        :return: an iterable over change notification dicts
        """
        if opts.get('feed') == 'continuous':
            return self._changes(**opts)

        if opts.get('filter') == '_selector':
            selector = opts.pop('_selector', None)
            _, _, data = self.resource.post_json('_changes', selector, **opts)
        else:
            _, _, data = self.resource.get_json('_changes', **opts)
        return data

